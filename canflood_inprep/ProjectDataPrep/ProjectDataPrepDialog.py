# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CanFlood_inPrepDialog
                                 A QGIS plugin
 This plugin preps CanFlood data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-02-19
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Tony De Crescenzo
        email                : tony.decrescenzo@ibigroup.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#==============================================================================
# standard imports
#==============================================================================
import sys, os, warnings, tempfile, logging, configparser, datetime
import os.path
from shutil import copyfile

#from qgis.PyQt import uic
#from qgis.PyQt import QtWidgets
from PyQt5 import uic
from PyQt5 import QtWidgets

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QObject 
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QListWidget, QTableWidgetItem

# Initialize Qt resources from file resources.py
#from .resources import *
# Import the code for the dialog

#from .canFlood_inPrep_dialog import CanFlood_inPrepDialog

from qgis.core import QgsProject, Qgis, QgsVectorLayer, QgsRasterLayer, QgsFeatureRequest

# User defined imports
from qgis.core import *
from qgis.analysis import *
import qgis.utils
import processing
from processing.core.Processing import Processing


sys.path.append(r'C:\IBI\_QGIS_\QGIS 3.8\apps\Python37\Lib\site-packages')
#sys.path.append(os.path.join(sys.exec_prefix, 'Lib/site-packages'))



"""
TODO: dependency check

"""
#==============================================================================
# pandas depdendency check
#==============================================================================
msg = 'requires pandas version >=0.25.3'
try:
    import pandas as pd
except:
    qgis.utils.iface.messageBar().pushMessage('CanFlood', msg, level=Qgis.Critical)
    raise ImportError(msg)
    
if not pd.__version__ >= '0.25.3':
    qgis.utils.iface.messageBar().pushMessage('CanFlood', msg, level=Qgis.Critical)
    raise ImportError(msg)


import numpy as np #Im assuming if pandas is fine, numpy will be fine

file_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(file_dir)
#import model
#from risk import RiskModel

#==============================================================================
# custom imports
#==============================================================================
import canflood_inprep.model.risk
import canflood_inprep.model.dmg
#import canflood_inprep.prep.wsamp
from canflood_inprep.prep.wsamp import WSLSampler
#from canFlood_model import CanFlood_Model
import canflood_inprep.hp as hp
from canflood_inprep.hp import Error


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ProjectDataPrepDialog_Base.ui'))


class DataPrep_Dialog(QtWidgets.QDialog, FORM_CLASS, WSLSampler, hp.QprojPlug):
    
    event_name_set = [] #event names
    
    invalid_cids = ['fid', 'ogc_fid']
    
    def __init__(self, iface, parent=None):
        """these will only ini tthe first baseclass (QtWidgets.QDialog)"""
        super(DataPrep_Dialog, self).__init__(parent)
        super(DataPrep_Dialog, self).__init__(parent)
        self.setupUi(self)
        
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

        self.ras = []
        self.ras_dict = {}
        self.vec = None

        self.iface = iface
        
        self.qproj_setup()
        

        
        #pull layer info from project
        layers = self.iface.mapCanvas().layers()
        layers_ras = [layer for layer in layers if layer.type() == QgsMapLayer.RasterLayer]
        layers_vec = [layer for layer in layers if layer.type() == QgsMapLayer.VectorLayer]
        
        # Set GUI elements
        self.comboBox_ras.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.comboBox_dtm.setFilters(QgsMapLayerProxyModel.RasterLayer)
        

        
        #======================================================================
        # scenario setup
        #======================================================================
        #gui elements
        self.comboBox_vec.setFilters(QgsMapLayerProxyModel.VectorLayer) #SS. Inventory Layer: Drop down
        self.comboBox_aoi.setFilters(QgsMapLayerProxyModel.VectorLayer) #SS. Project AOI
        self.comboBox_SSelv.addItems(['datum', 'ground'])
        
        self.comboBox_vec.layerChanged.connect(self.update_cid_cb)
        
        
        #======================================================================
        # """
        # development
        # """
        # self.lineEdit_cf_fp.setText(r'C:\LS\03_TOOLS\CanFlood\_wdirs\20200223d\CanFlood_scenario1.txt')
        # self.lineEdit_wd.setText(r'C:\LS\03_TOOLS\CanFlood\_wdirs\20200223d')
        #======================================================================
        
        
        
        
        #user input
        self.checkBox_SSoverwrite.stateChanged.connect(self.set_overwrite)
        
        self.pushButton_wd.clicked.connect(self.browse_wd) # SS. Working Dir. Browse
        self.pushButton_SScurves.clicked.connect(self.browse_curves)# SS. Vuln Curve Set. Browse
        self.pushButton_generate.clicked.connect(self.build_scenario) #SS. generate
        
        self.pushButton_cf.clicked.connect(self.select_output_file_cf)# SS. Model Control File. Browse
        
        #======================================================================
        # hazard sampler
        #======================================================================
        
        
        """not sure what/where this is
        self.pushButton_br_4.clicked.connect(self.select_output_file_cf)"""
        
        self.pushButton_remove.clicked.connect(self.remove_text_edit)
        self.pushButton_clear.clicked.connect(self.clear_text_edit)
        self.pushButton_add_all.clicked.connect(self.add_all_text_edit)
        
        self.comboBox_ras.currentTextChanged.connect(self.add_ras)
        
        #self.pushButton_HSgenerate.clicked.connect(self.run_wsamp)
        
        self.pushButton_HSgenerate.clicked.connect(self.run_wsamp)
        
        #======================================================================
        # event likelihoods
        #======================================================================
        self.pushButton_ELstore.clicked.connect(self.store_eaep)
        
        """dev button
        self.pushButton_ELdev.clicked.connect(self._pop_el_table)"""
        
        
        #======================================================================
        # Likelihood Sampler
        #======================================================================
        
        
        #======================================================================
        # DTM sampler
        #======================================================================
        self.pushButton_DTMsamp.clicked.connect(self.run_dsamp)
        
        
        #======================================================================
        # validator
        #======================================================================
        self.pushButton_Validate.clicked.connect(self.run_validate)
        
        
        
        #======================================================================
        # general
        #======================================================================

        self.buttonBox.accepted.connect(self.reject)
        

        self.buttonBox.rejected.connect(self.reject)
        self.pushButton_help.clicked.connect(self.run_help)
        
        
        """testing
        def test():
            self.logger.push('testing this')
        
        self.buttonBox.accepted.connect(test)"""
        
        
        
    
    #==========================================================================
    # UI Buttom Actions-----------------      
    #==========================================================================
              
    def browse_curves(self): #SS. Vulnerability Curve Set. file path
        """todo: set filter to xls only"""
        filename = QFileDialog.getOpenFileName(self, "Select Vulnerability Curve Set")[0] 
        if not filename == '':
            self.lineEdit_curve.setText(filename) #display the user selected filepath
             
            self.logger.push('curve set selected')
            self.logger.info(filename)


        
        
    def select_output_file_cf(self): #select an existing model control file
        filename = QFileDialog.getOpenFileName(self, "Select File")
        self.lineEdit_cf_fp.setText(str(filename[0]))
        self.lineEdit_control_2.setText(str(filename[0]))
        self.cf = str(filename[0])
        
        """
        TODO: Populate Vulnerability Curve Set box
        
        Check the control file is the correct format
        
        print out all the values pressent in the control file
        """
        
        self.iface.messageBar().pushMessage("CanFlood", "Pre-constructed Control File selected by User", level=Qgis.Info)
        
        QgsMessageLog.logMessage("usere selected control file from :\n    %s"%self.cf,
                                 'CanFlood', level=Qgis.Info)
        
        
        
        
    
    def browse_wd(self):
        wd = QFileDialog.getExistingDirectory(self, "Select Working Directory")
        if wd not in "": #see if it was cancelled
            self.lineEdit_wd.setText(os.path.normpath(wd))
            
        
            if not os.path.exists(wd):
                os.makedirs(wd)
                self.logger.info('requested working directory does not exist. built')
            
            self.logger.push('set working directory')
            
        
            

        
    def update_cid_cb(self): #update teh fields drop down any time the main layer changes
        
        try:
            #self.logger.info('user changed finv layer to %s'%self.comboBox_vec.currentLayer().name())
            self.mFieldComboBox_cid.setLayer(self.comboBox_vec.currentLayer()) #field selector
        except:
            self.logger.debug('failed set current layer')
        


        
        
    #==========================================================================
    # Layer Loading---------------
    #==========================================================================
    def add_ras(self):
        x = [str(self.listWidget_ras.item(i).text()) for i in range(self.listWidget_ras.count())]
        self.ras_dict.update({ (self.comboBox_ras.currentText()) : (self.comboBox_ras.currentLayer()) })
        if (self.comboBox_ras.currentText()) not in x:
            self.listWidget_ras.addItem(self.comboBox_ras.currentText())
            self.ras_dict.update({ (self.comboBox_ras.currentText()) : (self.comboBox_ras.currentLayer()) })
        
    def clear_text_edit(self):
        if len(self.ras_dict) > 0:
            self.listWidget_ras.clear()
            self.ras_dict = {}
    
    def remove_text_edit(self):
        if (self.listWidget_ras.currentItem()) is not None:
            value = self.listWidget_ras.currentItem().text()
            item = self.listWidget_ras.takeItem(self.listWidget_ras.currentRow())
            item = None
            for k in list(self.ras_dict):
                if k == value:
                    self.ras_dict.pop(value)

    def add_all_text_edit(self):
        layers = self.iface.mapCanvas().layers()
        #layers_vec = [layer for layer in layers if layer.type() == QgsMapLayer.VectorLayer]
        layers_ras = [layer for layer in layers if layer.type() == QgsMapLayer.RasterLayer]
        x = [str(self.listWidget_ras.item(i).text()) for i in range(self.listWidget_ras.count())]
        for layer in layers_ras:
            if (layer.name()) not in x:
                self.ras_dict.update( { layer.name() : layer} )
                self.listWidget_ras.addItem(str(layer.name()))

    #==========================================================================
    # tool commands------------                   
    #==========================================================================
    def run_help(self):
        """todo: link to help pdf"""
        raise Error('not implemented')
    
    
    def slice_aoi(self, vlay):
        
        aoi_vlay = self.comboBox_aoi.currentLayer()
        
        if aoi_vlay is None:
            self.logger.info('no aoi selected... not slicing')
            return vlay
        else:
            self.logger.warning('aoi slicing not impelemented')
            return vlay
            
            #raise Error('aoi slicing not implemented')
        
        
    
    def build_scenario(self): #called by Scenario Setup 'Build'
        
        self.tag = self.linEdit_ScenTag.text() #set the secnario tag from user provided name
        
        self.cid = self.mFieldComboBox_cid.currentField() #user selected field
        
        self.wd =  self.lineEdit_wd.text() #pull the wd filepath from the user provided in 'Browse'
        
        finv_fp = self.convert_finv() #convert the finv to csv and write to file
        
        #======================================================================
        # build the control file
        #======================================================================
        #called by build_scenario()
        dirname = os.path.dirname(os.path.abspath(__file__))
        
        #get the default template from the program files
        cf_src = os.path.join(dirname, '_documents/CanFlood_control_01.txt')
        #cf_src = os.path.join(dirname, '_documents/CanFlood_control_01.txt')
        
        #start the scratch file
        scratch_src = os.path.join(dirname, '_documents/scratch.txt')
        
        #get control file name from user provided tag
        cf_fn = 'CanFlood_%s.txt'%self.tag
        cf_path = os.path.join(self.wd, cf_fn)
        #cf_path = os.path.join(self.wd, 'CanFlood_control_01.txt')
        
        #see if this exists
        if os.path.exists(cf_path):
            msg = 'generated control file already exists. overwrite=%s \n     %s'%(
                self.overwrite, cf_path)
            if self.overwrite:
                self.logger.warning(msg)
            else:
                raise Error(msg)
            
        
        #copy over the default template
        copyfile(cf_src, cf_path)
            
        if not os.path.exists(scratch_src):
            open(scratch_src, 'w').close()
        
        #======================================================================
        # update the control file
        #======================================================================
        pars = configparser.ConfigParser(allow_no_value=True)
        _ = pars.read(cf_path) #read it from the new location
        
        #parameters
        pars.set('parameters', 'cid', self.cid) #user selected field
        pars.set('parameters', 'name', self.tag) #user selected field
        pars.set('parameters', 'felv', self.comboBox_SSelv.currentText()) #user selected field
        
        #filepaths
        pars.set('dmg_fps', 'curves',  self.lineEdit_curve.text())
        pars.set('dmg_fps', 'finv', finv_fp)
        
        """shoul donly be set by corresponding tools
        pars.set('dmg_fps', 'expos', os.path.normpath(os.path.join(self.wd, 'expos_test_1_7.csv')))
        pars.set('dmg_fps', '#expos file path set from wsamp.py')
        pars.set('dmg_fps', 'gels', os.path.normpath(os.path.join(self.wd, 'gel_cT1.csv')))"""
        
        """should only be set by the Impact model
        pars.set('risk_fps', 'dmgs', os.path.normpath(os.path.join(self.wd, 'dmg_results.csv')))
        pars.set('risk_fps', 'exlikes', os.path.normpath(os.path.join(self.wd, 'elikes_cT1.csv')))
        pars.set('risk_fps', 'aeps', os.path.normpath(os.path.join(self.wd, 'eaep_cT1.csv')))"""
        
        #set note
        pars.set('parameters', '#control file template created from \'scenario setup\' on  %s'%(
            datetime.datetime.now().strftime('%Y-%m-%d %H.%M.%S')
            ))
        
        #write the config file 
        with open(cf_path, 'w') as configfile:
            pars.write(configfile)
            
        QgsMessageLog.logMessage("default CanFlood model config file created :\n    %s"%cf_path,
                                 'CanFlood', level=Qgis.Info)
        
        """NO. should only populate this automatically from ModelControlFile.Browse
        self.lineEdit_curve.setText(os.path.normpath(os.path.join(self.wd, 'CanFlood - curve set 01.xls')))"""
        
        """TODO:
        write aoi filepath to scratch file
        """
        
        #======================================================================
        # wrap
        #======================================================================
        
        #display the control file in the dialog
        self.lineEdit_cf_fp.setText(cf_path)
        
        """not sure what this is
        self.lineEdit_control_2.setText(os.path.normpath(os.path.join(self.wd, 'CanFlood_control_01.txt')))"""
        
        self.logger.push("Scenario \'%s\' control file created"%self.tag)

        
    def convert_finv(self): #convert the finv vector to csv file
        
        #======================================================================
        # check the cid
        #======================================================================
        if self.cid == '' or self.cid in self.invalid_cids:
            raise Error('user selected invalid cid \'%s\''%self.cid)  
        
            
        
        #store the vecotr layer
        self.finv_vlay = self.comboBox_vec.currentLayer()
        
        #extract data
        df = hp.vlay_get_fdf(self.finv_vlay)
          
        #drop geometery indexes
        for gindx in self.invalid_cids:   
            df = df.drop(gindx, axis=1, errors='ignore')
            
        if not self.cid in df.columns:
            raise Error('cid not found in finv_df')
        
        #write it as a csv
        out_fp = os.path.join(self.wd, 'finv_%s_%s.csv'%(self.tag, self.finv_vlay.name()))
        df.to_csv(out_fp, index=False)  
        
        QgsMessageLog.logMessage("inventory csv written to file:\n    %s"%out_fp,
                                 'CanFlood', level=Qgis.Info)
        
        return out_fp
                
        

    
    def run_wsamp(self): #execute wsamp
        

        self.logger.info('user pressed \'pushButton_HSgenerate\'')
        #=======================================================================
        # assemble/prepare inputs
        #=======================================================================
        
        finv_raw = self.comboBox_vec.currentLayer()
        rlay_l = list(self.ras_dict.values())
        
        crs = self.qproj.crs()

        cf_fp1 = self.get_cf_fp()
        self.wd = self.lineEdit_wd.text()
        

        #update some parameters
        cid = self.mFieldComboBox_cid.currentField() #user selected field
        

        
         
        #======================================================================
        # """dev paths"""
        # cf_fp1 = r'C:\LS\03_TOOLS\CanFlood\_wdirs\20200222\CanFlood_run.txt'
        # wd = r'C:\LS\03_TOOLS\CanFlood\_wdirs\20200222'
        # cid = 'xid' #user selected field
        #======================================================================


        
        #======================================================================
        # aoi slice
        #======================================================================
        finv = self.slice_aoi(finv_raw)
        

        #======================================================================
        # precheck
        #======================================================================

        
        
        
        if finv is None:
            raise Error('got nothing for finv')
        if not isinstance(finv, QgsVectorLayer):
            raise Error('did not get a vector layer for finv')
        
        for rlay in rlay_l:
            if not isinstance(rlay, QgsRasterLayer):
                raise Error('unexpected type on raster layer')
            
        if not os.path.exists(self.wd):
            raise Error('working directory does not exist:  %s'%self.wd)
        
        if cid is None or cid=='':
            raise Error('need to select a cid')
        
        if not cid in [field.name() for field in finv.fields()]:
            raise Error('requested cid field \'%s\' not found on the finv_raw'%cid)
            
        
        #======================================================================
        # execute
        #======================================================================

        """
        2020-02-22: this is a very strange way of executing the backends.
        doesn't give us access to any of the gui (logger, status bar, crs, etc.)
        also defeats the purpose of writing the backends as methods
        changed so that we just inherit the backend as a baseclass
        
        
        canflood_inprep.prep.wsamp.main_run(rlay_l, finv, wd, cf_fp)
        self.iface.messageBar().pushMessage(
            "CanFlood", "Hazard Sampling Successful", level=Qgis.Success, duration=10)
        
        QgsMessageLog.logMessage('Hazard Sampling complete','CanFlood', level=Qgis.Info)"""
        
        finv = self.wsampRun(rlay_l, finv, control_fp=cf_fp1, cid=cid, crs=crs)
        
        #======================================================================
        # add to map
        #======================================================================
        if self.checkBox_HSloadres.isChecked():
            self.qproj.addMapLayer(finv)
            self.logger.info('added \'%s\' to canvas'%finv.name())
            
        #======================================================================
        # update event names
        #======================================================================
        self.event_name_set = [lay.name() for lay in rlay_l]
        
        self.logger.info('set %i event names: \n    %s'%(len(self.event_name_set), 
                                                         self.event_name_set))
        
        #======================================================================
        # populate the EL table
        #======================================================================
        
        l = self.event_name_set
        for tbl in [self.fieldsTable_LS, self.fieldsTable_EL]:

            tbl.setRowCount(len(l)) #add this many rows
            
            for rindx, ename in enumerate(l):
                tbl.setItem(rindx, 0, QTableWidgetItem(ename))
            
        self.logger.info('populated tables with event names')

        
        
        return
    
    def run_dsamp(self): #sample dtm raster
        
        self.logger.info('user pressed \'pushButton_DTMsamp\'')

        
        #=======================================================================
        # assemble/prepare inputs
        #=======================================================================
        
        finv_raw = self.comboBox_vec.currentLayer()
        rlay = self.comboBox_dtm.currentLayer()
        
        crs = self.qproj.crs()

        cf_fp1 = self.get_cf_fp()
        self.wd = self.lineEdit_wd.text()
        

        #update some parameters
        cid = self.mFieldComboBox_cid.currentField() #user selected field
        

        
         
        #======================================================================
        # """dev paths"""
        # cf_fp1 = r'C:\LS\03_TOOLS\CanFlood\_wdirs\20200222\CanFlood_run.txt'
        # wd = r'C:\LS\03_TOOLS\CanFlood\_wdirs\20200222'
        # cid = 'xid' #user selected field
        #======================================================================

        
        #======================================================================
        # aoi slice
        #======================================================================
        finv = self.slice_aoi(finv_raw)
        

        #======================================================================
        # precheck
        #======================================================================
                
        if finv is None:
            raise Error('got nothing for finv')
        if not isinstance(finv, QgsVectorLayer):
            raise Error('did not get a vector layer for finv')
        

        if not isinstance(rlay, QgsRasterLayer):
            raise Error('unexpected type on raster layer')
            
        if not os.path.exists(self.wd):
            raise Error('working directory does not exist:  %s'%self.wd)
        
        if cid is None or cid=='':
            raise Error('need to select a cid')
        
        if not cid in [field.name() for field in finv.fields()]:
            raise Error('requested cid field \'%s\' not found on the finv_raw'%cid)
            
        
        #======================================================================
        # execute
        #======================================================================
        
        finv = self.wsampRun([rlay], finv, control_fp=cf_fp1, cid=cid, crs=crs,
                             parkey= ('dmg_fps', 'gels'))
        
        #======================================================================
        # add to map
        #======================================================================
        if self.checkBox_DTMloadres.isChecked():
            self.qproj.addMapLayer(finv)
            self.logger.info('added \'%s\' to canvas'%finv.name())
            
            
        
    

    
    def _pop_el_table(self): #developing the table widget
        
        #======================================================================
        # dev data
        #======================================================================

        l = ['e1', 'e2', 'e3']
        tbl = self.fieldsTable_EL
        tbl.setRowCount(len(l)) #add this many rows
        
        for rindx, ename in enumerate(l):
            tbl.setItem(rindx, 0, QTableWidgetItem(ename))
            
        self.logger.push('populated likelihoods table with event names')
            
            
    
    def store_eaep(self): #saving the event likelihoods table to file

        self.logger.info('user pushed \'pushButton_ELstore\'')
        

        #======================================================================
        # collect variables
        #======================================================================
        #get displayed control file path
        cf_fp = self.get_cf_fp()
        
        
        #likelihood paramter
        if self.radioButton_ELari.isChecked():
            event_probs = 'ari'
        else:
            event_probs = 'aep'
        self.logger.info('\'event_probs\' set to \'%s\''%event_probs)
        
        
        #======================================================================
        # collcet table data
        #======================================================================

        df = hp.qtbl_get_df(self.fieldsTable_EL)
        
        self.logger.info('extracted data w/ %s \n%s'%(str(df.shape), df))
        
        # check it
        if df.iloc[:, 1].isna().any():
            raise Error('got %i nulls in the likelihood column'%df.iloc[:,1].isna().sum())
        
        miss_l = set(self.event_name_set).symmetric_difference(df.iloc[:,0].values)
        if len(miss_l)>0:
            raise Error('event name mismatch')
        
        
        #======================================================================
        # clean it
        #======================================================================
        aep_df = df.set_index(df.columns[0]).iloc[:,0].to_frame().T
        

        
        #======================================================================
        # #write to file
        #======================================================================
        ofn = os.path.join(self.lineEdit_wd.text(), 'aeps_%i_%s.csv'%(len(aep_df.columns), self.tag))
        eaep_fp = self.output_df(aep_df, ofn, write_index=False)
        
        
        
        #======================================================================
        # update the control file
        #======================================================================
        self.logger.info('reading control file: %s'%cf_fp)
        pars = configparser.ConfigParser(inline_comment_prefixes='#', allow_no_value=True)
        _ = pars.read(cf_fp) #read it
        
        pars.set('parameters', 'event_probs', event_probs) #user selected field
        pars.set('risk_fps', 'aeps', eaep_fp) #user selected field
        
        pars.set('risk_fps', '#aeps file path set from wsamp.py at %s'
                 %(datetime.datetime.now().strftime('%Y-%m-%d %H.%M.%S')))
                
                
        
        #write the config file 
        with open(cf_fp, 'w') as configfile:
            pars.write(configfile)
            
        self.logger.push('generated \'aeps\' and set \'event_probs\' to control file')
        
    def run_validate(self):
        """
        a lot of this is duplicated in  model.scripts_.setup_pars
        
        TODO: consolidate with setup_pars
        
        """
        log = self.logger.getChild('valid')
        log.info('user pressed \'pushButton_Validate\'')
        
        #======================================================================
        # load the control file
        #======================================================================
        #get the control file path
        cf_fp = self.get_cf_fp()
        
        #build/run theparser
        log.info('validating control file: \n    %s'%cf_fp)
        pars = configparser.ConfigParser(inline_comment_prefixes='#', allow_no_value=True)
        _ = pars.read(cf_fp) #read it
        
        #======================================================================
        # set the validation parameters
        #======================================================================
        #import the class objects
        from canflood_inprep.model.dmg import DmgModel
        from canflood_inprep.model.risk import RiskModel
        
        #populate all possible test parameters
        """
        todo: finish this
        """
        vpars_pos_d = {
                    'risk1':(self.checkBox_Vr1, ('risk_fps', None, None)),
                   'imp2':(self.checkBox_Vi2, ('dmg_fps', DmgModel.exp_dprops, DmgModel.exp_pars)),
                   'risk2':(self.checkBox_Vr2, ('risk_fps', None, None)),
                   #'risk2':(self.checkBox_Vr2, (RiskModel.exp_dprops, RiskModel.exp_pars)),
                   'risk3':(self.checkBox_Vr3, (None, None, None)),
                                           }
        
        #select based on user check boxes
        vpars_d = dict()
        for vtag, (checkBox, (section, eprops, epars)) in vpars_pos_d.items():
            if checkBox.isChecked():
                vpars_d[vtag] = (section, eprops, epars)
                
        if len(vpars_d) == 0:
            raise Error('no validation options selected!')
        
        log.info('user selected %i validation parameter sets'%len(vpars_d))
        
        #======================================================================
        # validate parameters
        #======================================================================
        dfiles_d = dict() #collective list of data files for secondary checking
        for vtag, (section, eprops, epars) in vpars_d.items():
            log.info('checking %s'%vtag)
            #==================================================================
            # #check variables
            #==================================================================
            if not epars is None:
                for sect_chk, vars_l in epars.items():
                    assert sect_chk in pars.sections(), 'missing expected section %s'%sect_chk
                    
                    for varnm in vars_l:
                        assert varnm in pars[sect_chk], 'missing expected variable \'%s.%s\''%(sect_chk, varnm)
            else:
                log.warning('\'%s\' has no variable validation parameters!'%vtag)
                    
                    
            #==================================================================
            # #check expected data files
            #==================================================================
            if not eprops is None:
                for varnm, dprops_d in eprops.items():
                    
                    #see if this is in the control file
                    assert varnm in pars[section], '\'%s\' expected \'%s.%s\''%(vtag, section, varnm)
                    
                    #get the filepath
                    fp = pars[section][varnm]
                    fh_clean, ext = os.path.splitext(os.path.split(fp)[1])
    
                    #check existance
                    if not os.path.exists(fp):
                        log.warning('specified \'%s\' filepath does not exist: \n    %s'%(varnm, fp))
                        continue
                    
                    #load the data
                    if ext == '.csv':
                        data = pd.read_csv(fp, header=0, index_col=None)
                    elif ext == '.xls':
                        data = pd.read_excel(fp)
                    else:
                        raise Error('unepxected filetype for \"%s.%s\' = \"%s\''%(vtag, varnm, ext))
                    
                    #add this to the collective
                    if not varnm in dfiles_d:
                        dfiles_d[varnm] = data
                    
                    
                    #check the data propoerites expectations
                    for chk_type, evals in dprops_d.items():
                        
                        #extension
                        if chk_type == 'ext':
                            assert ext in evals, '\'%s\' got unexpected extension: %s'%(varnm, ext)
                            
                        #column names
                        elif chk_type == 'colns':
                            miss_l = set(evals).difference(data.columns)
                            assert len(miss_l)==0, '\'%s\' is missing %i expected column names: %s'%(
                                varnm, len(miss_l), miss_l)
                            
                        else:
                            raise Error('unexpected chk_type: %s'%chk_type)
                        
                    log.info('%s.%s passed %i data expectation checks'%(
                        vtag, varnm, len(dprops_d)))
            else:
                log.warning('\'%s\' has no data property validation parameters!'%vtag)
                        
                
            #==================================================================
            # #set validation flag
            #==================================================================
            pars.set('validation', vtag, 'True')
            log.info('\'%s\' validated'%vtag)
            
        
        #======================================================================
        # secondary checks
        #======================================================================
        """for special data checks (that apply to multiple models)"""
        for dname, data in dfiles_d.items():
            pass
        
        #======================================================================
        # update control file
        #======================================================================
        with open(cf_fp, 'w') as configfile:
            pars.write(configfile)
            
        log.info('updated control file:\n    %s'%cf_fp)
            
            
        #======================================================================
        # wrap
        #======================================================================
        log.push('validated %i model parameter sets'%len(vpars_d))
        
        return
            
            
            
                    
                
            
        

            
            
             
        
        
        
                
                
            
    #==========================================================================
    # def run(self):
    #     # Do something useful here - delete the line containing pass and
    #     # substitute with your code.
    #     #=======================================================================
    #     # calculate poly stats
    #     #=======================================================================
    #     self.vec = self.comboBox_vec.currentLayer()
    #     self.ras = list(self.ras_dict.values())
    #     self.cf = self.lineEdit_cf_fp.text()
    #     if (self.vec is None or len(self.ras) == 0 or self.wd is None or self.cf is None):
    #         self.iface.messageBar().pushMessage("Input field missing",
    #                                              level=Qgis.Critical, duration=10)
    #         return
    #     
    #     """moved to build_scenario
    #     pars = configparser.ConfigParser(inline_comment_prefixes='#', allow_no_value=True)
    #     _ = pars.read(self.cf)
    #     pars.set('dmg_fps', 'curves', self.lineEdit_curve.text())
    #     with open(self.cf, 'w') as configfile:
    #         pars.write(configfile)"""
    #     
    #     
    #     canflood_inprep.prep.wsamp.main_run(self.ras, self.vec, self.wd, self.cf)
    #     self.iface.messageBar().pushMessage(
    #         "Success", "Process successful", level=Qgis.Success, duration=10)
    #     
    #==========================================================================

 

           
            
                    
            