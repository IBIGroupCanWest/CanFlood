# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CanFlood_inPrepDialog
                                 A QGIS plugin
 This plugin preps CanFlood data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-02-19
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Tony De Crescenzo
        email                : tony.decrescenzo@ibigroup.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

#from qgis.PyQt import uic
#from qgis.PyQt import QtWidgets
from PyQt5 import uic
from PyQt5 import QtWidgets

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QObject
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QListWidget

# Initialize Qt resources from file resources.py
#from .resources import *
# Import the code for the dialog

#from .canFlood_inPrep_dialog import CanFlood_inPrepDialog
import os.path
from qgis.core import QgsProject, Qgis, QgsVectorLayer, QgsRasterLayer, QgsFeatureRequest

# User defined imports
from qgis.core import *
from qgis.analysis import *
import qgis.utils
import processing
from processing.core.Processing import Processing
import sys, os, warnings, tempfile, logging, configparser

sys.path.append(r'C:\IBI\_QGIS_\QGIS 3.8\apps\Python37\Lib\site-packages')
#sys.path.append(os.path.join(sys.exec_prefix, 'Lib/site-packages'))
import numpy as np
import pandas as pd

file_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(file_dir)
#import model
#from risk import RiskModel

import canflood_inprep.model.risk
import canflood_inprep.model.dmg
import canflood_inprep.prep.wsamp
#from canFlood_model import CanFlood_Model
from canflood_inprep.hp import Error
from shutil import copyfile

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ProjectDataPrepDialog_Base.ui'))


class DataPrep_Dialog(QtWidgets.QDialog, FORM_CLASS):
    
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(DataPrep_Dialog, self).__init__(parent)
        self.setupUi(self)
        
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

        self.ras = []
        self.ras_dict = {}
        self.vec = None
        self.wd = None
        self.cf = None
        self.iface = iface
        
        layers = self.iface.mapCanvas().layers()
        layers_ras = [layer for layer in layers if layer.type() == QgsMapLayer.RasterLayer]
        layers_vec = [layer for layer in layers if layer.type() == QgsMapLayer.VectorLayer]
        
        # Set GUI elements
        self.comboBox_vec.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.comboBox_ras.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.comboBox_dtm.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.listWidget_ls.addItems(layer.name() for layer in layers_vec)
        self.listWidget_ls.setSelectionMode(QListWidget.MultiSelection)
        
        # Set folder/file browse buttons
        self.pushButton_br_1.clicked.connect(self.select_output_folder)
        self.pushButton_br_2.clicked.connect(self.select_output_file_vcs)
        self.pushButton_br_3.clicked.connect(self.select_output_file_cf)
        self.pushButton_br_4.clicked.connect(self.select_output_file_cf)
        self.pushButton_set.clicked.connect(self.set_wd)
        self.pushButton_remove.clicked.connect(self.remove_text_edit)
        self.pushButton_clear.clicked.connect(self.clear_text_edit)
        self.pushButton_add_all.clicked.connect(self.add_all_text_edit)
        
        self.comboBox_ras.currentTextChanged.connect(self.add_ras)
        
        self.buttonBox.accepted.connect(self.run)
        self.buttonBox.rejected.connect(self.reject)
        
            # Select input/output files/folders            
    def select_output_file_vcs(self):
        filename = QFileDialog.getOpenFileName(self, "Select File") 
        self.lineEdit_curve.setText(str(filename[0]))
        
    def select_output_file_cf(self):
        filename = QFileDialog.getOpenFileName(self, "Select File")
        self.lineEdit_control_1.setText(str(filename[0]))
        self.lineEdit_control_2.setText(str(filename[0]))
        self.cf = str(filename[0])
    
    def select_output_folder(self):
        foldername = QFileDialog.getExistingDirectory(self, "Select Directory")
        if foldername not in "":
            self.wd = foldername 
            self.lineEdit_wd.setText(os.path.normpath(foldername))
    
    # Functions related to hazard raster loading/unloading
    def add_ras(self):
        x = [str(self.listWidget_ras.item(i).text()) for i in range(self.listWidget_ras.count())]
        self.ras_dict.update({ (self.comboBox_ras.currentText()) : (self.comboBox_ras.currentLayer()) })
        if (self.comboBox_ras.currentText()) not in x:
            self.listWidget_ras.addItem(self.comboBox_ras.currentText())
            self.ras_dict.update({ (self.comboBox_ras.currentText()) : (self.comboBox_ras.currentLayer()) })
        
    def clear_text_edit(self):
        if len(self.ras_dict) > 0:
            self.listWidget_ras.clear()
            self.ras_dict = {}
    
    def remove_text_edit(self):
        if (self.listWidget_ras.currentItem()) is not None:
            value = self.listWidget_ras.currentItem().text()
            item = self.listWidget_ras.takeItem(self.listWidget_ras.currentRow())
            item = None
            for k in list(self.ras_dict):
                if k == value:
                    self.ras_dict.pop(value)

    def add_all_text_edit(self):
        layers = self.iface.mapCanvas().layers()
        #layers_vec = [layer for layer in layers if layer.type() == QgsMapLayer.VectorLayer]
        layers_ras = [layer for layer in layers if layer.type() == QgsMapLayer.RasterLayer]
        x = [str(self.listWidget_ras.item(i).text()) for i in range(self.listWidget_ras.count())]
        for layer in layers_ras:
            if (layer.name()) not in x:
                self.ras_dict.update( { layer.name() : layer} )
                self.listWidget_ras.addItem(str(layer.name()))

    # Functions related to setting file/folder paths and creating/setting control file                    
    def set_wd(self):
        self.wd =  self.lineEdit_wd.text()
        self.check_cf()
        self.lineEdit_curve.setText(os.path.normpath(os.path.join(self.wd, 'CanFlood - curve set 01.xls')))
        self.lineEdit_control_1.setText(os.path.normpath(os.path.join(self.wd, 'CanFlood_control_01.txt')))
        self.lineEdit_control_2.setText(os.path.normpath(os.path.join(self.wd, 'CanFlood_control_01.txt')))
        
    def check_cf(self):
        dirname = os.path.dirname(os.path.abspath(__file__))
        cf_src = os.path.join(dirname, '_documents/CanFlood_control_01.txt')
        #cf_src = os.path.join(dirname, '_documents/CanFlood_control_01.txt')
        scratch_src = os.path.join(dirname, '_documents/scratch.txt')
        cf_path = os.path.join(self.wd, 'CanFlood_control_01.txt')
        
        
        if not (os.path.isfile(cf_path)):
            copyfile(cf_src, cf_path)
            
        if not os.path.exists(scratch_src):
            open(scratch_src, 'w').close()
        
        pars = configparser.ConfigParser(inline_comment_prefixes='#', allow_no_value=True)
        _ = pars.read(cf_path)
        
        pars.set('dmg_fps', 'curves', os.path.normpath(os.path.join(self.wd, 'CanFlood - curve set 01.xls')))
        pars.set('dmg_fps', 'finv', os.path.normpath(os.path.join(self.wd, 'finv_icomp_cT1_heights.csv')))
        pars.set('dmg_fps', 'expos', os.path.normpath(os.path.join(self.wd, 'expos_test_1_7.csv')))
        pars.set('dmg_fps', '#expos file path set from wsamp.py')
        pars.set('dmg_fps', 'gels', os.path.normpath(os.path.join(self.wd, 'gel_cT1.csv')))
        
        pars.set('risk_fps', 'dmgs', os.path.normpath(os.path.join(self.wd, 'dmg_results.csv')))
        pars.set('risk_fps', 'exlikes', os.path.normpath(os.path.join(self.wd, 'elikes_cT1.csv')))
        pars.set('risk_fps', 'aeps', os.path.normpath(os.path.join(self.wd, 'eaep_cT1.csv')))
        
        with open(cf_path, 'w') as configfile:
            pars.write(configfile)
            
    def run(self):
        # Do something useful here - delete the line containing pass and
        # substitute with your code.
        #=======================================================================
        # calculate poly stats
        #=======================================================================
        self.vec = self.comboBox_vec.currentLayer()
        self.ras = list(self.ras_dict.values())
        self.cf = self.lineEdit_control_1.text()
        if (self.vec is None or len(self.ras) == 0 or self.wd is None or self.cf is None):
            self.iface.messageBar().pushMessage("Input field missing",
                                                 level=Qgis.Critical, duration=10)
            return
        
        pars = configparser.ConfigParser(inline_comment_prefixes='#', allow_no_value=True)
        _ = pars.read(self.cf)
        pars.set('dmg_fps', 'curves', self.lineEdit_curve.text())
        with open(self.cf, 'w') as configfile:
            pars.write(configfile)
        
        canflood_inprep.prep.wsamp.main_run(self.ras, self.vec, self.wd, self.cf)
        self.iface.messageBar().pushMessage(
            "Success", "Process successful", level=Qgis.Success, duration=10)