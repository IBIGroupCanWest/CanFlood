# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CanFlood_inPrepDialog
                                 A QGIS plugin
 This plugin preps CanFlood data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-02-19
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Tony De Crescenzo
        email                : tony.decrescenzo@ibigroup.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#==============================================================================
# standard imports
#==============================================================================
import sys, os, warnings, tempfile, logging, configparser, datetime
import os.path
from shutil import copyfile

#from qgis.PyQt import uic
#from qgis.PyQt import QtWidgets
from PyQt5 import uic
from PyQt5 import QtWidgets

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QObject
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QListWidget

# Initialize Qt resources from file resources.py
#from .resources import *
# Import the code for the dialog

#from .canFlood_inPrep_dialog import CanFlood_inPrepDialog

from qgis.core import QgsProject, Qgis, QgsVectorLayer, QgsRasterLayer, QgsFeatureRequest

# User defined imports
from qgis.core import *
from qgis.analysis import *
import qgis.utils
import processing
from processing.core.Processing import Processing


sys.path.append(r'C:\IBI\_QGIS_\QGIS 3.8\apps\Python37\Lib\site-packages')
#sys.path.append(os.path.join(sys.exec_prefix, 'Lib/site-packages'))
import numpy as np
import pandas as pd

file_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(file_dir)
#import model
#from risk import RiskModel

#==============================================================================
# custom imports
#==============================================================================
import canflood_inprep.model.risk
import canflood_inprep.model.dmg
#import canflood_inprep.prep.wsamp
from canflood_inprep.prep.wsamp import WSLSampler
#from canFlood_model import CanFlood_Model
import canflood_inprep.hp as hp
from canflood_inprep.hp import Error


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ProjectDataPrepDialog_Base.ui'))


class DataPrep_Dialog(QtWidgets.QDialog, FORM_CLASS, WSLSampler):
    
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(DataPrep_Dialog, self).__init__(parent)
        super(DataPrep_Dialog, self).__init__(parent)
        self.setupUi(self)
        
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

        self.ras = []
        self.ras_dict = {}
        self.vec = None
        self.wd = None
        self.cf = None
        self.iface = iface
        self.logger = hp.logger(self) #init the logger
        
        #pull layer info from project
        layers = self.iface.mapCanvas().layers()
        layers_ras = [layer for layer in layers if layer.type() == QgsMapLayer.RasterLayer]
        layers_vec = [layer for layer in layers if layer.type() == QgsMapLayer.VectorLayer]
        
        # Set GUI elements
        """need to convert this layer to a csv once 'Build' is clicked"""
        self.comboBox_vec.setFilters(QgsMapLayerProxyModel.VectorLayer) #SS. Inventory Layer: Drop down
        

        self.comboBox_aoi.setFilters(QgsMapLayerProxyModel.VectorLayer) #SS. Project AOI
        
        
        self.comboBox_ras.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.comboBox_dtm.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.listWidget_ls.addItems(layer.name() for layer in layers_vec)
        self.listWidget_ls.setSelectionMode(QListWidget.MultiSelection)
        
        #======================================================================
        # scenario setup
        #======================================================================
        #build from scratch
        self.pushButton_br_1.clicked.connect(self.select_output_folder) # SS. Working Dir. Browse
        self.pushButton_SScurves.clicked.connect(self.set_curves_fp)# SS. Vuln Curve Set. Browse
        self.pushButton_generate.clicked.connect(self.build_scenario) #SS. generate
        
        #optional select your own
        self.pushButton_br_3.clicked.connect(self.select_output_file_cf)# SS. Model Control File. Browse
        
        #======================================================================
        # hazard sampler
        #======================================================================
        
        
        """not sure what/where this is
        self.pushButton_br_4.clicked.connect(self.select_output_file_cf)"""
        
        self.pushButton_remove.clicked.connect(self.remove_text_edit)
        self.pushButton_clear.clicked.connect(self.clear_text_edit)
        self.pushButton_add_all.clicked.connect(self.add_all_text_edit)
        
        self.comboBox_ras.currentTextChanged.connect(self.add_ras)
        
        #self.pushButton_HSgenerate.clicked.connect(self.run_wsamp)
        
        self.pushButton_HSgenerate.clicked.connect(self.testit)
        
        
        #======================================================================
        # general
        #======================================================================
        """these should not execut especific tools
        self.buttonBox.accepted.connect(self.run)"""
        self.buttonBox.accepted.connect(self.reject)
        self.buttonBox.rejected.connect(self.reject)
        
    
    #==========================================================================
    # Select input/output files/folders ------------------        
    #==========================================================================
              
    def set_curves_fp(self): #SS. Vulnerability Curve Set. file path
        """todo: set filter to xls only"""
        filename = QFileDialog.getOpenFileName(self, "Select Vulnerability Curve Set") 
        self.lineEdit_curve.setText(str(filename[0])) #display the user selected filepath
        
        self.curves_fp = filename[0]
        
        QgsMessageLog.logMessage("user selected vulnerability curve set :\n    %s"%self.curves_fp,
                                 'CanFlood', level=Qgis.Info)
        
        """
        TODO: basic validity checks that this is the expected file t ype/structure 
        
        """
        
        
    def select_output_file_cf(self): #select an existing model control file
        filename = QFileDialog.getOpenFileName(self, "Select File")
        self.lineEdit_control_1.setText(str(filename[0]))
        self.lineEdit_control_2.setText(str(filename[0]))
        self.cf = str(filename[0])
        
        """
        TODO: Populate Vulnerability Curve Set box
        
        Check the control file is the correct format
        
        print out all the values pressent in the control file
        """
        
        self.iface.messageBar().pushMessage("CanFlood", "Pre-constructed Control File selected by User", level=Qgis.Info)
        
        QgsMessageLog.logMessage("usere selected control file from :\n    %s"%self.cf,
                                 'CanFlood', level=Qgis.Info)
        
        
        
        
    
    def select_output_folder(self):
        foldername = QFileDialog.getExistingDirectory(self, "Select Directory")
        if foldername not in "":
            self.wd = foldername 
            self.lineEdit_wd.setText(os.path.normpath(foldername))
    
    # Functions related to hazard raster loading/unloading
    def add_ras(self):
        x = [str(self.listWidget_ras.item(i).text()) for i in range(self.listWidget_ras.count())]
        self.ras_dict.update({ (self.comboBox_ras.currentText()) : (self.comboBox_ras.currentLayer()) })
        if (self.comboBox_ras.currentText()) not in x:
            self.listWidget_ras.addItem(self.comboBox_ras.currentText())
            self.ras_dict.update({ (self.comboBox_ras.currentText()) : (self.comboBox_ras.currentLayer()) })
        
    def clear_text_edit(self):
        if len(self.ras_dict) > 0:
            self.listWidget_ras.clear()
            self.ras_dict = {}
    
    def remove_text_edit(self):
        if (self.listWidget_ras.currentItem()) is not None:
            value = self.listWidget_ras.currentItem().text()
            item = self.listWidget_ras.takeItem(self.listWidget_ras.currentRow())
            item = None
            for k in list(self.ras_dict):
                if k == value:
                    self.ras_dict.pop(value)

    def add_all_text_edit(self):
        layers = self.iface.mapCanvas().layers()
        #layers_vec = [layer for layer in layers if layer.type() == QgsMapLayer.VectorLayer]
        layers_ras = [layer for layer in layers if layer.type() == QgsMapLayer.RasterLayer]
        x = [str(self.listWidget_ras.item(i).text()) for i in range(self.listWidget_ras.count())]
        for layer in layers_ras:
            if (layer.name()) not in x:
                self.ras_dict.update( { layer.name() : layer} )
                self.listWidget_ras.addItem(str(layer.name()))

    # Functions related to setting file/folder paths and creating/setting control file                    
    def build_scenario(self): #called by Scenario Setup 'Build'
        
        self.tag = self.linEdit_ScenTag.text() #set the secnario tag from user provided name
        
        self.wd =  self.lineEdit_wd.text() #pull the wd filepath from the user provided in 'Browse'
        
        self.finv_fp = self.convert_finv() #convert the finv to csv and write to file
        
        self.cf_fp = self.build_cf() #build the default control file
        
        """NO. should only populate this automatically from ModelControlFile.Browse
        self.lineEdit_curve.setText(os.path.normpath(os.path.join(self.wd, 'CanFlood - curve set 01.xls')))"""
        
        """TODO:
        write aoi filepath to scratch file
        """
        
        #display the control file in the dialog
        self.lineEdit_control_1.setText(self.cf_fp)
        
        """not sure what this is
        self.lineEdit_control_2.setText(os.path.normpath(os.path.join(self.wd, 'CanFlood_control_01.txt')))"""
        
        
        self.iface.messageBar().pushMessage("CanFlood", "Scenario \'%s\' control file created"%self.tag, level=Qgis.Info)
        
    def convert_finv(self): #convert the finv vector to csv file
        
        #store the vecotr layer
        self.finv_vlay = self.comboBox_vec.currentLayer()
        
        #extract data
        df = hp.vlay_get_fdf(self.finv_vlay)
        
        #write it as a csv
        out_fp = os.path.join(self.wd, 'finv_%s_%s.csv'%(self.tag, self.finv_vlay.name()))
        df.to_csv(out_fp, index=False)  
        
        QgsMessageLog.logMessage("inventory csv written to file:\n    %s"%out_fp,
                                 'CanFlood', level=Qgis.Info)
        
        return out_fp
                
        
    def build_cf(self): #build the default control file.
        #called by build_scenario()
        dirname = os.path.dirname(os.path.abspath(__file__))
        
        #get the default template from the program files
        cf_src = os.path.join(dirname, '_documents/CanFlood_control_01.txt')
        #cf_src = os.path.join(dirname, '_documents/CanFlood_control_01.txt')
        
        #start the scratch file
        scratch_src = os.path.join(dirname, '_documents/scratch.txt')
        
        #get control file name from user provided tag
        cf_fn = 'CanFlood_%s.txt'%self.tag
        cf_path = os.path.join(self.wd, cf_fn)
        #cf_path = os.path.join(self.wd, 'CanFlood_control_01.txt')
        
        #see if this exists
        if os.path.exists(cf_path):
            raise Error('generated control file already exists \n     %s'%cf_path)
            
        
        #copy over the default template
        copyfile(cf_src, cf_path)
            
        if not os.path.exists(scratch_src):
            open(scratch_src, 'w').close()
        
        #======================================================================
        # update the control file
        #======================================================================
        pars = configparser.ConfigParser(inline_comment_prefixes='#', allow_no_value=True)
        _ = pars.read(cf_path) #read it from the new location
        
        pars.set('dmg_fps', 'curves', self.curves_fp)
        pars.set('dmg_fps', 'finv', self.finv_fp)
        
        """shoul donly be set by corresponding tools
        pars.set('dmg_fps', 'expos', os.path.normpath(os.path.join(self.wd, 'expos_test_1_7.csv')))
        pars.set('dmg_fps', '#expos file path set from wsamp.py')
        pars.set('dmg_fps', 'gels', os.path.normpath(os.path.join(self.wd, 'gel_cT1.csv')))"""
        
        """should only be set by the Impact model
        pars.set('risk_fps', 'dmgs', os.path.normpath(os.path.join(self.wd, 'dmg_results.csv')))
        pars.set('risk_fps', 'exlikes', os.path.normpath(os.path.join(self.wd, 'elikes_cT1.csv')))
        pars.set('risk_fps', 'aeps', os.path.normpath(os.path.join(self.wd, 'eaep_cT1.csv')))"""
        
        #set note
        pars.set('parameters', '#control file template created from \'scenario setup\' on  %s'%(
            datetime.datetime.now().strftime('%Y-%m-%d %H.%M.%S')
            ))
        
        #write the config file 
        with open(cf_path, 'w') as configfile:
            pars.write(configfile)
            
        QgsMessageLog.logMessage("default CanFlood model config file created :\n    %s"%cf_path,
                                 'CanFlood', level=Qgis.Info)
        
        return cf_path
    
    def run_wsamp(self): #execute wsamp

        #=======================================================================
        # assemble/prepare inputs
        #=======================================================================
        #
        finv = self.comboBox_vec.currentLayer()
        rlay_l = list(self.ras_dict.values())
        cf_fp = self.lineEdit_control_1.text()
        wd = self.lineEdit_wd.text()

        #======================================================================
        # precheck
        #======================================================================
        if finv is None:
            raise Error('got nothing for finv')
        if not isinstance(finv, QgsVectorLayer):
            raise Error('did not get a vector layer for finv')
        
        for rlay in rlay_l:
            if not isinstance(rlay, QgsRasterLayer):
                raise Error('unexpected type on raster layer')
            
        if not os.path.exists(cf_fp):
            raise Error('control file does not exist: \n    %s'%cf_fp)
        
        if not os.path.exists(wd):
            raise Error('working directory does not exist: \n    %s'%wd)
        
        #======================================================================
        # execute
        #======================================================================

        """this is a very strange way of executing the backends.
        doesn't give us access to any of the gui (logger, status bar, crs, etc.)
        also defeats the purpose of writing the backends as methods"""
        
        
        canflood_inprep.prep.wsamp.main_run(rlay_l, finv, wd, cf_fp)
        self.iface.messageBar().pushMessage(
            "CanFlood", "Hazard Sampling Successful", level=Qgis.Success, duration=10)
        
        QgsMessageLog.logMessage('Hazard Sampling complete','CanFlood', level=Qgis.Info)
        
        return
                
                
            
    def run(self):
        # Do something useful here - delete the line containing pass and
        # substitute with your code.
        #=======================================================================
        # calculate poly stats
        #=======================================================================
        self.vec = self.comboBox_vec.currentLayer()
        self.ras = list(self.ras_dict.values())
        self.cf = self.lineEdit_control_1.text()
        if (self.vec is None or len(self.ras) == 0 or self.wd is None or self.cf is None):
            self.iface.messageBar().pushMessage("Input field missing",
                                                 level=Qgis.Critical, duration=10)
            return
        
        """moved to build_scenario
        pars = configparser.ConfigParser(inline_comment_prefixes='#', allow_no_value=True)
        _ = pars.read(self.cf)
        pars.set('dmg_fps', 'curves', self.lineEdit_curve.text())
        with open(self.cf, 'w') as configfile:
            pars.write(configfile)"""
        
        
        canflood_inprep.prep.wsamp.main_run(self.ras, self.vec, self.wd, self.cf)
        self.iface.messageBar().pushMessage(
            "Success", "Process successful", level=Qgis.Success, duration=10)
        

 

           
            
                    
            